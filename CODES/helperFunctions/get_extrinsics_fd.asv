function[panorama, extrinsics] = get_extrinsics_fd(odir, oname, images, t)


% get camera extrinsics using feature detection
%% Syntax
%
%
%% Description
%
%
%

viewId = 1;
I = im2gray(readimage(images, 1));
[m, n, ~] = size(I);
[prevPoints] = detectFeatures(I, Method);
[prevFeatures, prevPoints] = extractFeatures(I, prevPoints);

for viewId = 2:length(images.Files)

    clear curr*
    I = im2gray(readimage(images, viewId));
    imageSize(viewId,:) = size(I);

    % Detect and extract SURF features for I(n).
    [currPoints] = detectFeatures(I, Method);
    [currFeatures, currPoints] = extractFeatures(I, currPoints);

    % Find correspondences between I(n) and I(n-1).
    indexPairs = matchFeatures(currFeatures, prevFeatures, 'Unique', true);

    matchedPoints = currPoints(indexPairs(:,1), :);
    matchedPointsPrev = prevPoints(indexPairs(:,2), :);

    % Estimate the transformation between I(n) and I(n-1).
    tforms(viewId) = estgeotform2d(matchedPoints, matchedPointsPrev,...
        'projective', 'Confidence', 99.9, 'MaxNumTrials', 2000);

    % Compute T(1) * T(2) * ... * T(n-1) * T(n).
    tforms(viewId).A = tforms(viewId-1).A * tforms(viewId).A;

    clear prev*
    prevPoints = currPoints;
    prevFeatures = currFeatures;
end

for i = 1:numel(tforms)
    [xlim(i,:), ylim(i,:)] = outputLimits(tforms(i), [1 imageSize(i,2)], [1 imageSize(i,1)]);
end

maxImageSize = max(imageSize);

% Find the minimum and maximum output limits.
xMin = min([1; xlim(:)]);
xMax = max([maxImageSize(2); xlim(:)]);

yMin = min([1; ylim(:)]);
yMax = max([maxImageSize(1); ylim(:)]);

% Width and height of panorama.
width  = round(xMax - xMin);
height = round(yMax - yMin);

% Initialize the "empty" panorama.
panorama = zeros([height width 3], 'like', I);
blender = vision.AlphaBlender('Operation', 'Binary mask', ...
    'MaskSource', 'Input port');

% Create a 2-D spatial reference object defining the size of the panorama.
xLimits = [xMin xMax];
yLimits = [yMin yMax];
panoramaView = imref2d([height width], xLimits, yLimits);


% Create the panorama.
for i = 1:length(images.Files)

    I = readimage(images, i);

    % Transform I into the panorama.
    warpedImage = imwarp(I, tforms(i), 'OutputView', panoramaView);

    % Generate a binary mask.
    mask = imwarp(true(size(I,1),size(I,2)), tforms(i), 'OutputView', panoramaView);

    % Overlay the warpedImage onto the panorama.
    panorama = step(blender, panorama, warpedImage, mask);
end


extrinsics = tforms;

%  Save File
save(fullfile(odir, 'Processed_data', [oname '_IOEOVariable_' char(string(extract_Hz(hh))) 'Hz' ]),'extrinsics', 't')
figure(1);clf
imshow(panorama)
saveas(gca, fullfile(odir, 'Processed_data', [oname '_Panorama.png'])
end
